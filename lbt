#!/bin/sh

set -o errexit


lbrynet_local=y
config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/lbt"


mkdir -p "$config_dir"

if [ ! -f "$config_dir/mimetypes" ]; then
	echo \
"# This file determines rules for opening different types of files using 'lbt open'.
# Rules are ordered by priority, the ones at the top have the highest priority.

# First column is a glob pattern for matching MIME types.
# Second column is the action: \"save\" means that the file must be downloaded before opening, \"stream\" means that the program can open the file as an HTTP stream.
# Third column is the program to launch. \$1 is the stream URL/path to file, \$mimetype is the MIME type. Can be left empty if the second column says \"safe\"

#Uncomment this if you want to open files using XDG default applications:
#video/*	stream	gtk-launch \$(xdg-mime query default \$mimetype) \"\$1\"
#audio/*	stream	gtk-launch \$(xdg-mime query default \$mimetype) \"\$1\"
#text/html	stream	gtk-launch \$(xdg-mime query default \$mimetype) \"\$1\"
#*		save	gtk-launch \$(xdg-mime query default \$mimetype) \"\$1\"

video/*		stream	mpv \"\$1\"
audio/*		stream	mpv \"\$1\"
image/*		save	imv \"\$1\"
text/html	stream	\$BROWSER \"\$1\"
application/pdf	save	zathura \"\$1\"
*		save" \
	> "$config_dir/mimetypes"
fi


json_value() {
	echo "$1" | jq -r ".$2"
}

result_value() {
	echo "$1" | jq -r ".result.$2"
}


is_running() {
	case "$1" in
		\{* )
			#If starts with {, assume valid JSON
			if echo "$1" | grep -q '"is_running": true'; then
				return 0
			fi
			;;
	esac
	return 1

}

lbrynet_start_if_needed() {
	if ! pidof "lbrynet" > /dev/null; then
		printf_info "Starting LBRY daemon... "
		lbrynet start 2>/dev/null > /dev/null &
		while sleep 0.5; do
			lbrynet_status=$(lbrynet status)
			if is_running "$lbrynet_status"; then
				print_info "Done."
				break
			fi
		done
	fi
}

get_local_lbrynet_config() {
	lbrynet_config=$(lbrynet settings get)
#	streaming_server=$(json_value "$lbrynet_config" "streaming_server")
	api_server=$(json_value "$lbrynet_config" "api")
#	download_dir=$(json_value "$lbrynet_config" "download_dir")
}

lbrynet_get() {
	curl --silent -d"{\"method\": \"get\", \"params\": {\"uri\": \"$1\"}}" "$api_server"
}

lbrynet_sd_save() {
	curl --silent -d"{\"method\": \"file_save\", \"params\": {\"sd_hash\": \"$1\"}}" "$api_server"
}


is_download_complete() {
	echo "$1" | grep -F '"completed": true' -q
	return
}

#get_suggested_file_name() {
#        echo "$lbrynet_info" | awk '/suggested_file_name/{print substr($2, 2, length($2)-3)}'
#}

print_info() {
	if [ -z "$quiet" ]; then
		>&2 echo "$@"
	fi
	#echo "$@"
}

print_error() {
	#>&2 printf '\e[1;31m'"$@"'\e[0m\n' 
	>&2 echo "$@"
}

printf_info() {
	if [ -z "$quiet" ]; then
		>&2 printf "$@"
	fi
}


normalize_lbry_url() {
	case "$1" in
		https://lbry.tv/* | http://lbry.tv/* )
			echo "$1" | sed 's/\:/\#/g; s|.*lbry\.tv/|lbry://|'
			;;
		https://open.lbry.com/* | http://open.lbry.com/* )
			echo "$1" | sed 's/\:/\#/g; s|.*lbry\.com/|lbry://|'
			;;
		*)
			echo "$1"
			;;
	esac
}

request_download() {
	sd_hash="$(result_value "$lbrynet_info" "sd_hash")"
	lbrynet_sd_save "$sd_hash"
}

download() {
	printf_info "Downloading..."
	# suggested_file_name=$(result_value "$lbrynet_info" "suggested_file_name")
	# echo "Suggested file name is $suggested_file_name"

	sd_hash="$(result_value "$lbrynet_info" "sd_hash")"
	# echo "$sd_hash"

	while true; do
		file_info="$(lbrynet_sd_save "$sd_hash")"

		blobs_total="$(result_value "$file_info" "blobs_in_stream")"
		blobs_completed="$(result_value "$file_info" "blobs_completed")"
		printf_info '\rDownloading... %d/%d' "$blobs_completed" "$blobs_total"


		[ "$blobs_completed" -lt "$blobs_total" ] \
			|| break
		sleep 1
	done	
	printf_info "\n"
	
	result_value "$file_info" "download_path"
}


lbry_get_url() {
	if [ "$1" = "stream" ]; then
		result_value "$lbrynet_info" "streaming_url"
	elif [ "$1" = "save" ]; then
		if is_download_complete "$lbrynet_info"; then
			result_value "$lbrynet_info" "download_path"
		else
			download "$2"
		fi
	else
		print_info "Unknown action: $1"
		exit 1
	fi
}

do_mimetype_action() {
	mimetype_action=$(echo "$1" | cut -d' ' -f2)

	if [ -n "$save" ]; then
		action="save"
		if [ -n "$force_stream" ]; then
			print_info "Can't use --save-file and --force-stream options at the same time"
			exit 1
		fi
	elif [ -n "$force_stream" ]; then
		action="stream"
	else
		if [ "$mimetype_action" = "stream" ] && is_download_complete "$lbrynet_info"; then
			action="save"
		else
			action="$mimetype_action"
		fi
	fi


	url=$(lbry_get_url "$action" "$3")


	program=$(echo "$1" | cut -d' ' -f3- | awk "{\
		gsub(/\\\$1/, \"$url\"); \
		gsub(/\\\$mimetype/, \"$2\"); \
		print \$0; \
	}")
	if [ -z "$program" ]; then
		if [ "$mimetype_action" = "save" ]; then
			print_info "File saved to $url"
		else
			print_error 'Error: MIME type action is set to "stream" yet program is empty'
		fi
	else
		print_info "$program"
		#echo "$program" | $SHELL
		( eval "$program" )
	fi
}

handle_lbry_url() {
	# Ignore comments in config file and normalize whitespaces
	sed '/^ *#/d; s/#.*//; s/\s\+/ /g' < "$1" \
		| while read -r line; do
			mimetype_pattern="$(echo "$line" | cut -d' ' -f1)"
			case "$2" in
				$mimetype_pattern) 
					do_mimetype_action "$line" "$2" "$3"
					exit 0
					;;
			esac
		done
}






prepare() {
	lbrynet_start_if_needed

	get_local_lbrynet_config


	lbrynet_info="$(lbrynet_get "$url")"
	#echo "$lbrynet_info"
	case $lbrynet_info in
		\{* ) 
			# Assume valid JSON if starts with {
			;;
		* ) 
			print_error "Error: $lbrynet_info"
			exit 1
			;;
	esac


	error="$(result_value "$lbrynet_info" "error")"
	if [ "$error" != "null" ]; then
		print_error "Error: $error"
		exit 1
	fi
}


lbt_print_usage() {
	echo \
"Available commands:
	get 	Get content from an LBRY URL
	open 	Open LBRY content in the user's preferred application"
}

case "$1" in
	"open")
		lbt_command="open"
		shift
		;;
	"get")
		lbt_command="get"
		shift
		;;
	"-h"|"--help")
		echo "Usage: lbt COMMAND ..."
		lbt_print_usage
		exit 0
		;;
	"")
		echo "Usage: lbt COMMAND ..."	
		lbt_print_usage
		exit 1
		;;
	*)
		echo "Unknown command: $1"
		lbt_print_usage
		exit 1
		;;
esac


open() {
	options=mhfsq
	longopts=get-mime,help,save-file,force-stream,quiet
	parsed=$(getopt --options=$options --longoptions=$longopts --name "$0" -- "$@")
	eval set -- "$parsed"
#	echo "$@"

	while true; do
		case "$1" in
			-h|--help)
				help=y
				shift
				;;
			-m|--get-mime)
				get_mimetype=y
				shift
				;;
			-f|--save-file)
				save=y
				shift
				;;
			-s|--force-stream)
				force_stream=y
				shift
				;;
			-q|--quiet)
				quiet=y
				shift
				;;
			--)
				shift
				break
				;;
			*)
				echo "Programming error"
				echo "$1"
				exit 1
				;;
		esac
	done



	if [ -n "$help" ]; then
		echo \
"Usage: lbt open URL [options...]

	-f, --save-file 	Save content as a file even if it can be streamed
	-h, --help 		Print help
	-m, --get-mime 		Get MIME type of the LBRY content and exit
	-q, --quiet 		Don't output extra information, besides error messages
	-s, --force-stream 	Use HTTP stream even if the file is saved on this machine"
		exit 0
	fi



	if [ -z "$1" ]; then
		echo "Usage: lbt open URL [option...]"
		echo "Try 'lbt open --help' to get more information"
		exit 1
	fi

	url="$(normalize_lbry_url "$1")"
	if [ "$url" != "$1" ]; then
		print_info "Resolving $url..."
	fi


	prepare

	mimetype=$(result_value "$lbrynet_info" "mime_type")

	if [ -n "$get_mimetype" ]; then
		echo "MIME type is $mimetype"
		exit 0
	fi

	handle_lbry_url "$config_dir/mimetypes" "$mimetype" "$url"
}




output_to_file() {
	if [ "$lbrynet_local" = y ] && is_download_complete "$2"; then
		download_path=$(result_value "$2" "download_path")
		if [ -n "$force_save" ]; then
			if [ -z "$quiet" ]; then
				printf "Copying from %s... " "$download_path"
			fi
			cp "$download_path" "$1"
			if [ -z "$quiet" ]; then
				echo "Done."
			fi
		else
			ln -s "$download_path" "$1"
			if [ -z "$quiet" ]; then
				echo "Created symlink from $1 to $download_path"
			fi
		fi
		exit 0
	fi
	if [ -n "$quiet" ]; then
		curl_initial_args="--silent"
	else
		curl_initial_args="--progress-meter"
	fi
	curl "$curl_initial_args" "$(result_value "$2" "streaming_url")" -o "$1"
	exit 0
}


get() {
	options=rhfsto:Fq
	longopts=resolve,help,file,stream,terminal,output:,force-save,quiet
	parsed=$(getopt --options=$options --longoptions=$longopts --name "$0" -- "$@")
	eval set -- "$parsed"
#	echo "$@"
	
	while true; do
		case "$1" in
			-h|--help)
				help=y
				shift
				;;
			-r|--resolve)
				resolve=y
				shift
				;;
			-f|--file)
				save=y
				shift
				;;
			-s|--stream)
				force_stream=y
				shift
				;;
			-t|--terminal)
				allow_terminal=y
				shift
				;;
			-o|--output)
				output_file="$2"
				shift 2
				;;
			-F|--force-save)
				force_save=y
				shift
				;;
			-q|--quiet)
				quiet=y
				shift
				;;
			--)
				shift
				break
				;;
			*)
				echo "Programming error: unknown parameter $1"
				exit 1
				;;
		esac
	done

	if [ -n "$help" ]; then
		echo \
"Usage: lbt get URL [options...]

	-f, --file		Save content as a file and print download path
	-F, --force-save 	Save content as a file even if that's not needed
	-h, --help		Print help
	-O, --output FILE 	Write output to FILE (or, if the content already exists on the local machine, create a sym-link)
	-q, --quiet 		Don't output extra information, besides error messages
	-r, --resolve		Instead of printing file to stdout, print either an HTTP URL or a local file path
	-s, --stream		Create HTTP stream and print its URL
	-t, --terminal		Enable printing output to the terminal"
	fi

	if [ -n "$quiet" ]; then
		allow_terminal=y
	fi

	if [ -z "$1" ]; then
		echo "Usage: lbt get URL -f|-s [option...]"
		echo "Try 'lbt get --help' to get more information"
		exit 1
	fi


	if [ -n "$output_file" ]; then
		if [ -n "$resolve" ]; then
			print_error "Error: --output and --resolve are incompatible options"
			exit 1
		fi
	fi



	if [ -n "$save" ]; then
		action="save"
		if [ -n "$force_stream" ]; then
			print_error "Error: --file and --stream options cannot be used at the same time."
			exit 1
		fi
		if [ -z "$resolve" ]; then
			print_error "Error: --file option must be used with --resolve"
			exit 1
		fi
	elif [ -n "$force_stream" ]; then
		action="stream"
		if [ -z "$resolve" ]; then
			print_error "Error: --stream option must be used with --resolve"
			exit 1
		fi
	else
		if [ -n "$resolve" ]; then
			print_error "Error: either --file or --stream option must be used with --resolve"
			exit 1
		fi
	fi

	if [ -z "$resolve" ] && [ -z "$output_file" ] && [ -z "$allow_terminal" ] && [ -t 1 ]; then
		print_info "Are you sure you want to print this data into a terminal?"
		printf_info "\n(use the --terminal option to skip this)\033[F"
		printf_info "Type 'y' to proceed, or 'n' to exit: "
	
		first_print=y
		while read -r result; do
			if [ -n "$first_print" ]; then
				printf_info '\n'
				unset first_print
			fi

			if [ "$result" = y ]; then
				break
			elif [ "$result" = n ]; then
				exit 0
			fi
			printf_info "Type 'y' to proceed, or 'n' to exit: "
		done
	fi


	url="$(normalize_lbry_url "$1")"
	if [ "$url" != "$1" ]; then
		print_info "Resolving $url..."
	fi


	prepare



	if [ -n "$output_file" ]; then
		output_to_file "$output_file" "$lbrynet_info"
	elif [ -n "$resolve" ]; then
		lbry_get_url "$action" "$url"
	else
		if [ -z "$action" ]; then
			if is_download_complete "$lbrynet_info"; then
				cat "$(result_value "$lbrynet_info" "download_path")"
			else
				curl --silent "$(result_value "$lbrynet_info" "streaming_url")"
			fi
		elif [ "$action" = "save" ]; then
			if ! is_download_complete "$lbrynet_info"; then
				cat "$(download "$url")"
			else
				cat "$(result_value "$lbrynet_info" "download_path")"
			fi
		elif [ "$action" = "stream" ]; then
			curl --silent "$(result_value "$lbrynet_info" "streaming_url")"
		fi
	fi
}


case "$lbt_command" in
	open )
		open "$@"
		;;
	get )
		get "$@"
		;;
	* )
		echo "Programming error: unknown command??"
		exit 1
		;;
esac

