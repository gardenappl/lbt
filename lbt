#!/bin/sh

set -o errexit


lbrynet_local=y
config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/lbt"


mkdir -p "$config_dir"

if [ ! -f "$config_dir/mimetypes" ]; then
	echo \
'# This file determines rules for opening different types of files using "lbt open".
# Rules are ordered by priority, the ones at the top have the highest priority.

# First column is a glob pattern for matching MIME types.
# Second column is the action: "save" means that the file must be downloaded before opening, "stream" means that the program can open the file as an HTTP stream.
# Third column is the program to launch. $1 is the stream URL/path to file, $mimetype is the MIME type. Can be left empty if the second column says "safe"

#Uncomment this if you want to open files using XDG default applications:
#video/*	stream	gtk-launch $(xdg-mime query default $mimetype) "$1"
#audio/*	stream	gtk-launch $(xdg-mime query default $mimetype) "$1"
#text/html	stream	gtk-launch $(xdg-mime query default $mimetype) "$1"
#*		save	gtk-launch $(xdg-mime query default $mimetype) "$1"

video/*		stream	mpv "$1"
audio/*		stream	mpv "$1"
image/*		save	imv "$1"
text/html	stream	$BROWSER "$1"
application/pdf	save	zathura "$1"
*		save' 
	> "$config_dir/mimetypes"
fi


lbt_help_open() {
	echo \
"Usage: lbt open URL [options...]

	-f, --save-file 	Save content as a file even if it can be streamed
	-h, --help 		Print help
	-m, --get-mime 		Get MIME type of the LBRY content and exit
	-q, --quiet 		Don't output extra information, besides error messages
	-s, --force-stream 	Use HTTP stream even if the file is saved on this machine"
}

lbt_help_ls() {
	echo \
"Usage: lbt ls [options...]

	-b, --blobs			List downloaded and total blobs
	-c, --channel			List channel name
	    --color WHEN 		Output result with color (always,auto,never)
	-d, --full			Only list content that's fully downloaded
	-e, --empty			Only list content which has no downloaded blobs
	-f, --files			Only list content that's saved as a local file
	-F, --not-files			Only list content that's not saved as a local file
	-h, --human-readable WHEN 	Output size in human readable units (always,auto,never)
	    --help			Print help
	-l, --pretty WHEN 		Synonym for --color --human-readable --table
	-m, --mime			List MIME type
	-n, --no-path			Don't list file paths
	-N, --no-name			Don't list claim names
	-P, --absolute-path		List absolute paths instead of relative
	-R, --relative-path		List relative paths, even when piping output
	-r, --reverse 			Reverse order when sorting
	-s, --size			List total of the file
	--sort KEY 			Sort values by key (name,channel,size,mime,time)
	-t, --no-time 			Don't list time of first access
	-T, --table WHEN 		Output result as a table (always,auto,never)"
}

lbt_help_get() {
	echo \
"Usage: lbt get URL [options...]

	-f, --file		Save content as a file and print download path
	-F, --force-save 	Save content as a file even if that's not needed
	-h, --help		Print help
	-O, --output FILE 	Write output to FILE (or, if the content already exists on the local machine, create a sym-link)
	-q, --quiet 		Don't output extra information, besides error messages
	-r, --resolve		Instead of printing file to stdout, print either an HTTP URL or a local file path
	-s, --stream		Create HTTP stream and print its URL
	-t, --terminal		Enable printing output to the terminal"
}


json_value() {
	echo "$1" | jq -r ".$2"
}

result_value() {
	echo "$1" | jq -r ".result.$2"
}

# from dylanaraps' Pure Sh Bible, MIT License
trim_quotes() {

	# Disable globbing.
	# This makes the word-splitting below safe.
	set -f

	# Store the current value of 'IFS' so we
	# can restore it later.
	old_ifs=$IFS

	# Set 'IFS' to ["'].
	IFS=\"\'

	# Create an argument list, splitting the
	# string at ["'].
	#
	# Disable this shellcheck error as it only
	# warns about word-splitting which we expect.
	# shellcheck disable=2086
	set -- $1

	# Set 'IFS' to blank to remove spaces left
	# by the removal of ["'].
	IFS=

	# Print the quote-less string.
	printf '%s' "$*"

	# Restore the value of 'IFS'.
	IFS=$old_ifs

	# Re-enable globbing.
	set +f
}



lbrynet_check_error() {
	case "$1" in
		\{* )
			#If starts with {. assume valid JSON
			case "$1" in
				*'"error": {'* )
					print_error "Error in LBRY daemon."
					print_error "$1"
					exit 1
					;;
			esac
			;;
		* )
			print_error "Error in LBRY daemon."
			print_error "$1"
			exit 1
			;;
	esac
}


is_running() {
	case "$1" in
		\{* )
			#If starts with {, assume valid JSON
			case "$1" in
				*'"is_running": true'* )
					return 0
					;;
			esac
			;;
	esac
	return 1
}

lbrynet_start_if_needed() {
	if ! pidof "lbrynet" > /dev/null; then
		printf_info "Starting LBRY daemon... "
		lbrynet start 2>/dev/null > /dev/null &
		while sleep 0.5; do
			lbrynet_status=$(lbrynet status)
			if is_running "$lbrynet_status"; then
				print_info "Done."
				break
			fi
		done
	fi
}

get_local_lbrynet_config() {
	lbrynet_config=$(lbrynet settings get)
	lbrynet_check_error "$lbrynet_config"
#	streaming_server=$(json_value "$lbrynet_config" "streaming_server")
	api_server=$(json_value "$lbrynet_config" "api")
#	download_dir=$(json_value "$lbrynet_config" "download_dir")
}

lbrynet_get() {
	curl --silent -d"{\"method\": \"get\", \"params\": {\"uri\": \"$1\"}}" "$api_server"
}

lbrynet_get_save() {
	curl --silent -d"{\"method\": \"get\", \"params\": {\"uri\": \"$1\", \"save_file\": true}}" "$api_server"
}


is_download_complete() {
	case "$1" in
		*'"completed": true'* )
			return 0
			;;
		*)
			return 1
			;;
	esac
}

#get_suggested_file_name() {
#        echo "$lbrynet_info" | awk '/suggested_file_name/{print substr($2, 2, length($2)-3)}'
#}

print_info() {
	if [ -z "$quiet" ]; then
		>&2 echo "$@"
	fi
	#echo "$@"
}

print_error() {
	#>&2 printf '\e[1;31m'"$@"'\e[0m\n' 
	>&2 echo "$@"
}

printf_info() {
	if [ -z "$quiet" ]; then
		>&2 printf "$@"
	fi
}


. gettext.sh

TEXTDOMAIN=lbt
export TEXTDOMAIN

check_incompatible() {
	if [ -n "$1" ] && [ -n "$2" ]; then
		opt1="$3"
		opt2="$4"
		>&2 eval_gettext 'Error: $opt1 and $opt2 are incompatible options.'; echo
		exit 1
	fi
}


normalize_lbry_url() {
	case "$1" in
		https://lbry.tv/* | http://lbry.tv/* )
			echo "$1" | sed 's/\:/\#/g; s|.*lbry\.tv/|lbry://|'
			;;
		https://open.lbry.com/* | http://open.lbry.com/* )
			echo "$1" | sed 's/\:/\#/g; s|.*lbry\.com/|lbry://|'
			;;
		*)
			echo "$1"
			;;
	esac
}

download() {
	printf_info "Downloading..."
	# suggested_file_name=$(result_value "$lbrynet_info" "suggested_file_name")
	# echo "Suggested file name is $suggested_file_name"

	# echo "$sd_hash"

	while true; do
		lbrynet_info="$(lbrynet_get_save "$1")"
		lbrynet_check_error "$lbrynet_info"

		blobs_total="$(result_value "$lbrynet_info" "blobs_in_stream")"
		blobs_completed="$(result_value "$lbrynet_info" "blobs_completed")"
		printf_info '\rDownloading... %d/%d' "$blobs_completed" "$blobs_total"


		[ "$blobs_completed" -lt "$blobs_total" ] \
			|| break
		sleep 1
	done	
	printf_info "\n"
	
	result_value "$lbrynet_info" "download_path"
}


lbry_get_url() {
	if [ "$1" = "stream" ]; then
		result_value "$lbrynet_info" "streaming_url"
	elif [ "$1" = "save" ]; then
		if is_download_complete "$lbrynet_info"; then
			result_value "$lbrynet_info" "download_path"
		else
			download "$2"
		fi
	else
		print_info "Unknown action: $1"
		exit 1
	fi
}

do_mimetype_action() {
	mimetype_action=$(echo "$1" | cut -d' ' -f2)

	if [ -n "$save" ]; then
		action="save"
		if [ -n "$force_stream" ]; then
			print_info "Can't use --save-file and --force-stream options at the same time"
			exit 1
		fi
	elif [ -n "$force_stream" ]; then
		action="stream"
	else
		if [ "$mimetype_action" = "stream" ] && is_download_complete "$lbrynet_info"; then
			action="save"
		else
			action="$mimetype_action"
		fi
	fi


	url=$(lbry_get_url "$action" "$3")


	program=$(echo "$1" | cut -d' ' -f3- | sed "s|\$1|$url|g; s|\$mimetype|$2|")
	if [ -z "$program" ]; then
		if [ "$mimetype_action" = "save" ]; then
			print_info "File saved to $url"
		else
			print_error 'Error: MIME type action is set to "stream" yet program is empty'
		fi
	else
		print_info "$program"
		#echo "$program" | $SHELL
		( eval "$program" )
	fi
}

handle_lbry_url() {
	# Ignore comments in config file and normalize whitespaces
	sed '/^ *#/d; s/#.*//; s/\s\+/ /g' < "$1" \
		| while read -r line; do
			mimetype_pattern="$(echo "$line" | cut -d' ' -f1)"
			case "$2" in
				$mimetype_pattern) 
					do_mimetype_action "$line" "$2" "$3"
					exit 0
					;;
			esac
		done
}






prepare() {
	lbrynet_start_if_needed

	get_local_lbrynet_config

	lbrynet_info="$(lbrynet_get "$url")"
	lbrynet_check_error "$lbrynet_info"
}


lbt_print_usage() {
	echo \
"Available commands:
	get 	Get content from an LBRY URL
	ls 	List stored LBRY content
	open 	Open LBRY content in the user's preferred application"
}


open() {
	options=mhfsq
	longopts=get-mime,help,save-file,force-stream,quiet
	parsed=$(getopt --options=$options --longoptions=$longopts --name "$0" -- "$@")
	eval set -- "$parsed"
#	echo "$@"

	while true; do
		case "$1" in
			-h|--help)
				help=y
				shift
				;;
			-m|--get-mime)
				get_mimetype=y
				shift
				;;
			-f|--save-file)
				save=y
				shift
				;;
			-s|--force-stream)
				force_stream=y
				shift
				;;
			-q|--quiet)
				quiet=y
				shift
				;;
			--)
				shift
				break
				;;
			*)
				echo "Programming error"
				echo "$1"
				exit 1
				;;
		esac
	done



	if [ -n "$help" ]; then
		lbt_help_open
		exit 0
	fi



	if [ -z "$1" ]; then
		echo "Usage: lbt open URL [option...]"
		echo "Try 'lbt open --help' to get more information"
		exit 1
	fi

	url="$(normalize_lbry_url "$1")"
	if [ "$url" != "$1" ]; then
		print_info "Resolving $url..."
	fi


	prepare

	mimetype=$(result_value "$lbrynet_info" "mime_type")

	if [ -n "$get_mimetype" ]; then
		echo "MIME type is $mimetype"
		exit 0
	fi

	handle_lbry_url "$config_dir/mimetypes" "$mimetype" "$url"
}




output_to_file() {
	if [ "$lbrynet_local" = y ] && is_download_complete "$2"; then
		download_path=$(result_value "$2" "download_path")
		if [ -n "$force_save" ]; then
			if [ -z "$quiet" ]; then
				printf "Copying from %s... " "$download_path"
			fi
			cp "$download_path" "$1"
			if [ -z "$quiet" ]; then
				echo "Done."
			fi
		else
			ln -s "$download_path" "$1"
			if [ -z "$quiet" ]; then
				echo "Created symlink from $1 to $download_path"
			fi
		fi
		exit 0
	fi
	if [ -n "$quiet" ]; then
		curl_initial_args="--silent"
	else
		curl_initial_args="--progress-meter"
	fi
	curl "$curl_initial_args" "$(result_value "$2" "streaming_url")" -o "$1"
	exit 0
}


get() {
	options=rhfsto:Fq
	longopts=resolve,help,file,stream,terminal,output:,force-save,quiet
	parsed=$(getopt --options=$options --longoptions=$longopts --name "$0" -- "$@")
	eval set -- "$parsed"
#	echo "$@"
	
	while true; do
		case "$1" in
			-h|--help)
				help=y
				shift
				;;
			-r|--resolve)
				resolve=y
				shift
				;;
			-f|--file)
				save=y
				shift
				;;
			-s|--stream)
				force_stream=y
				shift
				;;
			-t|--terminal)
				allow_terminal=y
				shift
				;;
			-o|--output)
				output_file="$2"
				shift 2
				;;
			-F|--force-save)
				force_save=y
				shift
				;;
			-q|--quiet)
				quiet=y
				shift
				;;
			--)
				shift
				break
				;;
			*)
				echo "Programming error: unknown parameter $1"
				exit 1
				;;
		esac
	done

	if [ -n "$help" ]; then
		lbt_help_get
	fi

	if [ -n "$quiet" ]; then
		allow_terminal=y
	fi

	if [ -z "$1" ]; then
		echo "Usage: lbt get URL -f|-s [option...]"
		echo "Try 'lbt get --help' to get more information"
		exit 1
	fi


	check_incompatible "$output_file" "$resolve" "--output" "--resolve"

	check_incompatible "$save" "$force_stream" "--file" "--stream"
	if [ -n "$save" ]; then
		action="save"
		if [ -z "$resolve" ]; then
			print_error "Error: --file option must be used with --resolve"
			exit 1
		fi
	elif [ -n "$force_stream" ]; then
		action="stream"
		if [ -z "$resolve" ]; then
			print_error "Error: --stream option must be used with --resolve"
			exit 1
		fi
	else
		if [ -n "$resolve" ]; then
			print_error "Error: either --file or --stream option must be used with --resolve"
			exit 1
		fi
	fi

	if [ -z "$resolve" ] && [ -z "$output_file" ] && [ -z "$allow_terminal" ] && [ -t 1 ]; then
		print_info "Are you sure you want to print this data into a terminal?"
		printf_info "\n(use the --terminal option to skip this)\033[F"
		printf_info "Type 'y' to proceed, or 'n' to exit: "
	
		first_print=y
		while read -r result; do
			if [ -n "$first_print" ]; then
				printf_info '\n'
				unset first_print
			fi

			if [ "$result" = y ]; then
				break
			elif [ "$result" = n ]; then
				exit 0
			fi
			printf_info "Type 'y' to proceed, or 'n' to exit: "
		done
	fi


	url="$(normalize_lbry_url "$1")"
	if [ "$url" != "$1" ]; then
		print_info "Resolving $url..."
	fi


	prepare



	if [ -n "$output_file" ]; then
		output_to_file "$output_file" "$lbrynet_info"
	elif [ -n "$resolve" ]; then
		lbry_get_url "$action" "$url"
	else
		if [ -z "$action" ]; then
			if is_download_complete "$lbrynet_info"; then
				cat "$(result_value "$lbrynet_info" "download_path")"
			else
				curl --silent "$(result_value "$lbrynet_info" "streaming_url")"
			fi
		elif [ "$action" = "save" ]; then
			if ! is_download_complete "$lbrynet_info"; then
				cat "$(download "$url")"
			else
				cat "$(result_value "$lbrynet_info" "download_path")"
			fi
		elif [ "$action" = "stream" ]; then
			curl --silent "$(result_value "$lbrynet_info" "streaming_url")"
		fi
	fi
}


lbrynet_list_files() {
	page=1
	total_pages=1

	# Setting up filters for jq

	# Download path must always be requested, so that we can later filter out
	# --files or --not-files claims
	columns="p: .download_path"
	total_columns=1
	if [ -z "$ls_no_name" ]; then
		columns="n: .claim_name, $columns"
		total_columns=$((total_columns + 1))
	fi
	if [ -z "$ls_no_time" ]; then
		columns="a: .added_on, $columns"
		time_column=1
		total_columns=$((total_columns + 1))
	fi
	if [ -n "$ls_size" ]; then
		columns="s: .total_bytes, $columns"
		size_column=1
		time_column=$((time_column + 1))
		total_columns=$((total_columns + 1))
	fi
	if [ -n "$ls_channel" ]; then
		columns="c: .channel_name, $columns"
		size_column=$((size_column + 1))
		time_column=$((time_column + 1))
		total_columns=$((total_columns + 1))
	fi
	if [ -n "$ls_mime_type" ]; then
		columns="$columns, m: .mime_type"
		mime_column=$((total_columns + 1))
		total_columns=$((total_columns + 1))
	fi
	if [ -n "$ls_blobs" ]; then
		columns="b: .blobs_completed, t: .blobs_in_stream, $columns"
		mime_column=$((mime_column + 1))
		size_column=$((size_column + 1))
		time_column=$((time_column + 1))
		total_columns=$((total_columns + 1))
	fi

	# In all of these cases, we need attributes like $is_full or $is_empty
	if [ -n "$ls_color" ] || [ -n "$ls_size" ] || [ -n "$ls_full" ] \
			|| [ -n "$ls_empty" ] || [ -n "$ls_not_empty" ]; then
		columns="e: .blobs_completed, r: .blobs_remaining, $columns"
	fi

	while [ $page -le $total_pages ]; do
		case "$ls_sort" in
			name )
				list_params=', "sort": "claim_name"'
				;;
			channel )
				list_params=', "sort": "channel_name"'
				;;
			time )
				list_params=', "sort": "added_on"'
				;;
			# sorting by size, MIME type, etc. is handled separately
		esac

		list_info="$(curl --silent -d"{\"method\": \"file_list\", \"params\": {\"page\": $page, \"page_size\": 1000000$list_params}}" "$api_server")"
		lbrynet_check_error "$list_info"

		#
		# Here we will construct the final command for interpreting the JSON output
		#

		#no-op pipe, we will build a command on top of it
		output_command="tee"

		if [ -n "$ls_size" ]; then
			if [ "$ls_sort" = "size" ]; then
				if [ -n "$ls_reverse" ]; then
					sort_params="--reverse"
				fi
				output_command="$output_command | sort $sort_params --field-separator='\"' --numeric-sort \
					--key=$size_column --key=$((size_column + 1))"
			fi

			output_command="$output_command | awk \
				'BEGIN { FS = \"\\\"\"; OFS = \"\\\"\" } \
				{ sub(/./, \"\", \$$size_column); print }'"

			if [ "$ls_human" = y ]; then
				output_command="$output_command | sed 's/\"/!!TEMP!!\"/$size_column' \
					| numfmt --to=iec-i --field=$((size_column + 1)) --delimiter=\\\" --invalid=ignore \
					| sed 's/!!TEMP!!\"//g'"
			else
				output_command="$output_command | sed 's/\"//$size_column'"
			fi
		fi

		if [ -z "$ls_no_time" ]; then
			# Set TIME to the content of time_column, without color codes
			# Replace TIME in time_column with a formatted time string
			output_command="$output_command | awk \
				'BEGIN { FS = \"\\\"\"; OFS = \"\\\"\" } { \
				\
					TIME = \$$time_column; \
					CUR_TIME = systime(); \
				\
					sub(/\\033\[38;5;\\Sm/,\"\",TIME); \
				\
					if (strftime(\"%Y\", TIME) == strftime(\"%Y\", CUR_TIME)) \
						FORMAT = \"%b %d %R\"; \
					else \
						FORMAT = \"%b %d %Y\"; \
				\
					sub(TIME, strftime(FORMAT, TIME), \$$time_column); \
					print \
				}'"
		fi

		if [ -n "$ls_mime_type" ] && [ "$ls_sort" = "mime" ]; then
			if [ -n "$ls_reverse" ]; then
				sort_params="--reverse"
			fi
			output_command="$output_command | sort $sort_params --field-separator='\"' --key=$mime_column"
		fi

		if [ -n "$ls_reverse" ]; then
			# "size" and "mime" sort reversal is handled separately
			if [ "$ls_sort" != "size" ] && [ "$ls_sort" != "mime" ]; then
				output_command="$output_command | tac"
			fi
		fi

		if [ "$ls_table" = y ]; then
			output_command="$output_command | column --table --separator=\\\""
		else
			output_command="$output_command | sed s/\\\"/\\\t/g"
		fi

		#
		# $output_command constructed
		#

		# Filter LBRY data using jq, output properties line by line
		# Process them and combine them into one line
		echo "$list_info" | jq ".result.items|.[]|{$columns}" | sed 's/,$//' | while read -r line; do
			case "$line" in
				\{ )
					continue
					;;
				\} )
					printf '\n'
					continue
					;;
			esac
			case "$line" in
				\"a\"* )
					if [ "$ls_color" = y ]; then
						printf '\033[38;5;4m%s' "$line"
					else
						printf '%s' "$line"
					fi
					;;
				"\"e\": 0" )
					if [ -n "$ls_not_empty" ]; then
						printf '""DELETE THIS""'
					fi
					is_empty=y
					continue
					;;
				\"e\"* )
					unset is_empty
					if [ -n "$ls_empty" ]; then
						printf '""DELETE THIS""'
					fi
					continue
					;;
				"\"r\": 0" )
					is_full=y
					continue
					;;
				\"r\"* )
					unset is_full
					if [ -n "$ls_full" ]; then
						printf '""DELETE THIS""'
					fi
					continue
					;;
				\"s\"* )
					if [ -n "$is_full" ]; then
						# The numbets will be removed later,
						# this is just so that the sort algorithm
						# places empty, in-progress, and full files
						# in the correct order
						printf '3'
						if [ "$ls_color" = y ]; then
							printf '\033[38;5;2m'
						fi
					elif [ -n "$is_empty" ]; then
						printf '1'
						if [ "$ls_color" = y ]; then
							printf '\033[38;5;1m'
						fi
						printf '!'
					else
						printf '2'
						if [ "$ls_color" = y ]; then
							printf '\033[38;5;3m'
						fi
						printf '<'
					fi
					# Print color at the end of the previous column,
					# as opposed to this column, so that
					# numfmt doesn't have to deal with the escape codes.
					printf ',\t%s' "$line"
					;;
				\"m\"* )
					if [ "$ls_color" = y ]; then
						printf '\033[38;5;5m%s' "$line"
					else
						printf '%s' "$line"
					fi
					;;
				\"b\"* )
					blobs_completed="$line"
					continue
					;;
				\"t\"* )
					if [ "$ls_color" = y ]; then
						if [ -n "$is_full" ]; then
							printf '\033[38;5;2m'
						elif [ -n "$is_empty" ]; then
							printf '\033[38;5;1m'
						else
							printf '\033[38;5;3m'
						fi
					fi

					printf '%s/%s' "$blobs_completed" "$line"
					;;
				"\"c\": null" )
					;;
				\"c\"* )
					if [ "$ls_color" = y ]; then
						printf '\033[38;5;6m\033[1m%s\033[m' "$line"
					else
						printf '%s' "$line"
					fi
					;;
				\"n\"* )
					if [ "$ls_color" = y ]; then
						if [ -n "$is_full" ]; then
							printf '\033[38;5;2m'
						elif [ -n "$is_empty" ]; then
							printf '\033[38;5;1m'
						else
							printf '\033[38;5;3m'
						fi
						printf '\033[1m%s\033[m' "$line"
					else
						printf '%s' "$line"
					fi
					;;
				"\"p\": null")
					if [ -n "$ls_files" ]; then
						printf '""DELETE THIS""'
					fi
					;;
				\"p\"* )
					if [ "$ls_color" = y ]; then
						printf '\033[m'
					fi
					if [ -n "$ls_not_files" ]; then
						printf '""DELETE THIS""'
					elif [ -n "$ls_relative_path" ]; then
						filename="$(echo "$line" | cut -d' ' -f2)"
						filename="$(trim_quotes "$filename")"
						printf '%s' "$(realpath --relative-base="$PWD" "$filename")"
					elif [ -n "$ls_path" ]; then
						printf '%s' "$line"
					fi
					;;
				\"h\"* )
					printf '%s' "$line"
					;;
			esac
			printf ',\t'
		#Clean up our "temporary" JSON, separate fields with " characters
		done | sed '/""DELETE THIS""/d; s/"\w": //g; s/"//g; s/,\t/"/g; s/"$//' | eval "$output_command"

		total_pages="$(result_value "$list_info" "total_pages")"
		page=$((page+1))
	done
}

lbt_ls() {
	options=nNPcfFNbmdeERT::sh::rl::t
	longopts=help,no-path,absolute-path,channel,files,not-files,no-name,blobs,mime-type,full,empty,not-empty,color::,relative-path,table::,size,human-readable::,sort:,reverse,pretty::,time
	parsed=$(getopt --options=$options --longoptions=$longopts --name "$0" -- "$@")
	eval set -- "$parsed"
#	echo "$@"

	while true; do
		case "$1" in
			-t|--no-time )
				ls_no_time=y
				shift
				;;
			-l|--pretty )
				case "$2" in
					"" )
						ls_pretty=y
						;;
					always )
						ls_pretty=y
						;;
					auto )
						ls_pretty=auto
						;;
					never )
						ls_pretty=n
						;;
					* )
						print_error "Unknown parameter for --pretty-print: $2"
						print_error "Available options: always, auto, never"
						exit 1
						;;
				esac
				shift 2
				;;
			-r|--reverse )
				ls_reverse=y
				shift
				;;
			--sort )
				case "$2" in
					time )
						ls_sort=time
						;;
					name )
						ls_sort=name
						;;
					size )
						ls_sort=size
						;;
					channel )
						ls_sort=channel
						;;
					mime )
						ls_sort=mime
						;;
					* )
						print_error "Unknown parameter for --sort: $2"
						print_error "Available options: name, channel, size, mime"
						exit 1
						;;
				esac
				shift 2
				;;
			-E|--not-empty )
				ls_not_empty=y
				shift
				;;
			-h|--human-readable )
				case "$2" in
					"" )
						ls_human=y
						;;
					always )
						ls_human=y
						;;
					auto )
						;;
					never )
						ls_human=n
						;;
					* )
						print_error "Unknown parameter for --human-readable: $2"
						print_error "Available options: always, auto, never"
						exit 1
						;;
				esac
				shift 2
				;;	
			-s|--size )
				ls_size=y
				shift
				;;
			-T|--table )
				case "$2" in
					"" )
						ls_table=y
						;;
					always )
						ls_table=y
						;;
					auto )
						;;
					never )
						ls_table=n
						;;
					* )
						print_error "Unknown parameter for --table: $2"
						print_error "Available options: always, auto, never"
						exit 1
						;;
				esac
				shift 2
				;;
			--color )
				case "$2" in
					"" )
						ls_color=y
						;;
					always )
						ls_color=y
						;;
					auto )
						;;
					never )
						ls_color=n
						;;
					* )
						print_error "Unknown parameter for --color: $2"
						print_error "Available options: always, auto, never"
						exit 1
						;;
				esac
				shift 2
				;;
			-d|--full )
				ls_full=y
				shift
				;;
			-e|--empty )
				ls_empty=y
				shift
				;;
			-m|--mime-type )
				ls_mime_type=y
				shift
				;;
			-N|--no-name )
				ls_no_name=y
				shift
				;;
			-R|--relative-path)
				ls_relative_path=y
				shift
				;;
			-b|--blobs )
				ls_blobs=y
				shift
				;;
			#-H|--sd-hash )
			#	ls_sd_hash=y
			#	shift
			#	;;
			-f|--files )
				ls_files=y
				shift
				;;
			-F|--not-files )
				ls_not_files=y
				shift
				;;
			--help )
				help=y
				shift
				;;
			-n|--no-path )
				ls_no_path=y
				shift
				;;
			-P|--absolute-path )
				ls_path=y
				shift
				;;
			-c|--channel )
				ls_channel=y
				shift
				;;
			-- )
				shift
				break
				;;
			* )
				echo "Programming error"
				echo "$1"
				exit 1
				;;
		esac
	done

	check_incompatible "$ls_no_path" "$ls_path" "--no-path" "--absolute-path"
	check_incompatible "$ls_relative_path" "$ls_path" "--relative-path" "--absolute-path"
	check_incompatible "$ls_relative_path" "$ls_no_path" "--relative-path" "--no-path"
	if [ -z "$ls_no_path" ] && [ -z "$ls_path" ] && [ -z "$ls_relative_path" ]; then
		if [ -t 1 ]; then
			ls_relative_path=y
		else
			ls_path=y
		fi
	fi

	check_incompatible "$ls_full" "$ls_empty" "--full" "--empty"
	check_incompatible "$ls_not_empty" "$ls_empty" "--not-empty" "--empty"

	if [ -n "$ls_pretty" ]; then
		if [ "$ls_pretty" = "auto" ]; then
			if [ -t 1 ]; then
				ls_pretty=y
			else
				ls_pretty=n
			fi
			unset ls_pretty
		else
			ls_human="${ls_human:-$ls_pretty}"
			ls_color="${ls_color:-$ls_pretty}"
			ls_table="${ls_table:-$ls_pretty}"
		fi
	fi


	if [ -t 1 ]; then
		ls_human="${ls_human:-y}"
		ls_color="${ls_color:-y}"
		ls_table="${ls_table:-y}"
	else
		ls_human="${ls_human:-n}"
		ls_color="${ls_color:-n}"
		ls_table="${ls_table:-n}"
	fi

	check_incompatible "$ls_files" "$ls_not_files" "--files" "--not-files"
	check_incompatible "$ls_no_name" "$ls_no_path" "--no-name" "--no-path"
	if [ -n "$ls_no_name" ]; then
		if [ -z "$ls_files" ]; then
			print_error "Error: --no-name option requires --files"
			exit 1
		fi
	fi


	if [ "$ls_sort" = "mime" ] && [ -z "$ls_mime_type" ]; then
		print_error "Error: --sort=mime requires --mime"
		exit 1
	elif [ "$ls_sort" = "size" ] && [ -z "$ls_size" ]; then
		print_error "Error: --sort=size requires --size"
		exit 1
	fi
	
	#if [ -z "$ls_sort" ] && [ -n "$ls_reverse" ]; then
	#	print_error "Error: --reverse requires --sort"
	#	exit 1
	#fi


	if [ -n "$help" ]; then
		lbt_help_ls
		exit 0
	fi


	lbrynet_start_if_needed
	get_local_lbrynet_config


	lbrynet_list_files
}

lbt_help_generic() {
	echo "Usage: lbt COMMAND..."
	echo "   or  lbt --help COMMAND..."
	lbt_print_usage			
}

while true; do
	case "$1" in
		"open")
			lbt_command="open"
			shift
			break
			;;
		"get")
			lbt_command="get"
			shift
			break
			;;
		"ls")
			lbt_command="ls"
			shift
			break
			;;
		"-h"|"--help")
			lbt_help=y
			shift
			;;
		"")
			lbt_help_generic
			if [ -n "$lbt_help" ]; then
				exit 0
			else
				exit 1
			fi
			;;
		*)
			echo "Unknown command: $1"
			lbt_print_usage
			exit 1
			;;
	esac
done

case "$lbt_command" in
	open )
		if [ -n "$lbt_help" ]; then
			lbt_help_open
			exit 0
		fi
		open "$@"
		;;
	get )
		if [ -n "$lbt_help" ]; then
			lbt_help_get
			exit 0
		fi
		get "$@"
		;;
	ls )
		if [ -n "$lbt_help" ]; then
			lbt_help_ls
			exit 0
		fi
		lbt_ls "$@"
		;;
	* )
		echo "Programming error: unknown command??"
		exit 1
		;;
esac

