#!/bin/sh

set -o errexit


lbrynet_local=y
config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/lbt"


mkdir -p "$config_dir"

if [ ! -f "$config_dir/mimetypes" ]; then
	echo \
'# This file determines rules for opening different types of files using 'lbt open'.
# Rules are ordered by priority, the ones at the top have the highest priority.

# First column is a glob pattern for matching MIME types.
# Second column is the action: "save" means that the file must be downloaded before opening, "stream" means that the program can open the file as an HTTP stream.
# Third column is the program to launch. $1 is the stream URL/path to file, $mimetype is the MIME type. Can be left empty if the second column says "safe"

#Uncomment this if you want to open files using XDG default applications:
#video/*	stream	gtk-launch $(xdg-mime query default $mimetype) "$1"
#audio/*	stream	gtk-launch $(xdg-mime query default $mimetype) "$1"
#text/html	stream	gtk-launch $(xdg-mime query default $mimetype) "$1"
#*		save	gtk-launch $(xdg-mime query default $mimetype) "$1"

video/*		stream	mpv "$1"
audio/*		stream	mpv "$1"
image/*		save	imv "$1"
text/html	stream	$BROWSER "$1"
application/pdf	save	zathura "$1"
*		save' 
	> "$config_dir/mimetypes"
fi


lbt_help_open() {
	echo \
"Usage: lbt open URL [options...]

	-f, --save-file 	Save content as a file even if it can be streamed
	-h, --help 		Print help
	-m, --get-mime 		Get MIME type of the LBRY content and exit
	-q, --quiet 		Don't output extra information, besides error messages
	-s, --force-stream 	Use HTTP stream even if the file is saved on this machine"
}

lbt_help_ls() {
	echo \
"Usage: lbt ls [options...]

	-b, --blobs 		List downloaded and total blobs
	-c, --channel 		List channel name
	-d, --full 		Only list content that's fully downloaded
	-e, --empty 		Only list content which has no downloaded blobs
	-f, --files 		Only list content that's saved as a local file
	-F, --not-files 	Only list content that's not saved as a local file
	-h, --help 		Print help
	-n, --no-path 		Don't list file paths
	-N, --no-name 		Don't list claim names
	-P, --absolute-path 	List absolute paths instead of relative
	-r, --relative-path 	List relative paths, even when piping output"
}

lbt_help_get() {
	echo \
"Usage: lbt get URL [options...]

	-f, --file		Save content as a file and print download path
	-F, --force-save 	Save content as a file even if that's not needed
	-h, --help		Print help
	-O, --output FILE 	Write output to FILE (or, if the content already exists on the local machine, create a sym-link)
	-q, --quiet 		Don't output extra information, besides error messages
	-r, --resolve		Instead of printing file to stdout, print either an HTTP URL or a local file path
	-s, --stream		Create HTTP stream and print its URL
	-t, --terminal		Enable printing output to the terminal"
}


json_value() {
	echo "$1" | jq -r ".$2"
}

result_value() {
	echo "$1" | jq -r ".result.$2"
}

# from dylanaraps' Pure Sh Bible, MIT License
trim_quotes() {

	# Disable globbing.
	# This makes the word-splitting below safe.
	set -f

	# Store the current value of 'IFS' so we
	# can restore it later.
	old_ifs=$IFS

	# Set 'IFS' to ["'].
	IFS=\"\'

	# Create an argument list, splitting the
	# string at ["'].
	#
	# Disable this shellcheck error as it only
	# warns about word-splitting which we expect.
	# shellcheck disable=2086
	set -- $1

	# Set 'IFS' to blank to remove spaces left
	# by the removal of ["'].
	IFS=

	# Print the quote-less string.
	printf '%s' "$*"

	# Restore the value of 'IFS'.
	IFS=$old_ifs

	# Re-enable globbing.
	set +f
}



is_running() {
	case "$1" in
		\{* )
			#If starts with {, assume valid JSON
			if echo "$1" | grep -F '"is_running": true'-q ; then
				return 0
			fi
			;;
	esac
	return 1

}

lbrynet_start_if_needed() {
	if ! pidof "lbrynet" > /dev/null; then
		printf_info "Starting LBRY daemon... "
		lbrynet start 2>/dev/null > /dev/null &
		while sleep 0.5; do
			lbrynet_status=$(lbrynet status)
			if is_running "$lbrynet_status"; then
				print_info "Done."
				break
			fi
		done
	fi
}

get_local_lbrynet_config() {
	lbrynet_config=$(lbrynet settings get)
#	streaming_server=$(json_value "$lbrynet_config" "streaming_server")
	api_server=$(json_value "$lbrynet_config" "api")
#	download_dir=$(json_value "$lbrynet_config" "download_dir")
}

lbrynet_get() {
	curl --silent -d"{\"method\": \"get\", \"params\": {\"uri\": \"$1\"}}" "$api_server"
}

lbrynet_sd_save() {
	curl --silent -d"{\"method\": \"file_save\", \"params\": {\"sd_hash\": \"$1\"}}" "$api_server"
}


is_download_complete() {
	echo "$1" | grep -F '"completed": true' -q
	return
}

#get_suggested_file_name() {
#        echo "$lbrynet_info" | awk '/suggested_file_name/{print substr($2, 2, length($2)-3)}'
#}

print_info() {
	if [ -z "$quiet" ]; then
		>&2 echo "$@"
	fi
	#echo "$@"
}

print_error() {
	#>&2 printf '\e[1;31m'"$@"'\e[0m\n' 
	>&2 echo "$@"
}

printf_info() {
	if [ -z "$quiet" ]; then
		>&2 printf "$@"
	fi
}


. gettext.sh

TEXTDOMAIN=lbt
export TEXTDOMAIN

check_incompatible() {
	if [ -n "$1" ] && [ -n "$2" ]; then
		opt1="$3"
		opt2="$4"
		>&2 eval_gettext 'Error: $opt1 and $opt2 are incompatible options.'; echo
		exit 1
	fi
}


normalize_lbry_url() {
	case "$1" in
		https://lbry.tv/* | http://lbry.tv/* )
			echo "$1" | sed 's/\:/\#/g; s|.*lbry\.tv/|lbry://|'
			;;
		https://open.lbry.com/* | http://open.lbry.com/* )
			echo "$1" | sed 's/\:/\#/g; s|.*lbry\.com/|lbry://|'
			;;
		*)
			echo "$1"
			;;
	esac
}

request_download() {
	sd_hash="$(result_value "$lbrynet_info" "sd_hash")"
	lbrynet_sd_save "$sd_hash"
}

download() {
	printf_info "Downloading..."
	# suggested_file_name=$(result_value "$lbrynet_info" "suggested_file_name")
	# echo "Suggested file name is $suggested_file_name"

	sd_hash="$(result_value "$lbrynet_info" "sd_hash")"
	# echo "$sd_hash"

	while true; do
		file_info="$(lbrynet_sd_save "$sd_hash")"

		blobs_total="$(result_value "$file_info" "blobs_in_stream")"
		blobs_completed="$(result_value "$file_info" "blobs_completed")"
		printf_info '\rDownloading... %d/%d' "$blobs_completed" "$blobs_total"


		[ "$blobs_completed" -lt "$blobs_total" ] \
			|| break
		sleep 1
	done	
	printf_info "\n"
	
	result_value "$file_info" "download_path"
}


lbry_get_url() {
	if [ "$1" = "stream" ]; then
		result_value "$lbrynet_info" "streaming_url"
	elif [ "$1" = "save" ]; then
		if is_download_complete "$lbrynet_info"; then
			result_value "$lbrynet_info" "download_path"
		else
			download "$2"
		fi
	else
		print_info "Unknown action: $1"
		exit 1
	fi
}

do_mimetype_action() {
	mimetype_action=$(echo "$1" | cut -d' ' -f2)

	if [ -n "$save" ]; then
		action="save"
		if [ -n "$force_stream" ]; then
			print_info "Can't use --save-file and --force-stream options at the same time"
			exit 1
		fi
	elif [ -n "$force_stream" ]; then
		action="stream"
	else
		if [ "$mimetype_action" = "stream" ] && is_download_complete "$lbrynet_info"; then
			action="save"
		else
			action="$mimetype_action"
		fi
	fi


	url=$(lbry_get_url "$action" "$3")


	program=$(echo "$1" | cut -d' ' -f3- | awk "{\
		gsub(/\\\$1/, \"$url\"); \
		gsub(/\\\$mimetype/, \"$2\"); \
		print \$0; \
	}")
	if [ -z "$program" ]; then
		if [ "$mimetype_action" = "save" ]; then
			print_info "File saved to $url"
		else
			print_error 'Error: MIME type action is set to "stream" yet program is empty'
		fi
	else
		print_info "$program"
		#echo "$program" | $SHELL
		( eval "$program" )
	fi
}

handle_lbry_url() {
	# Ignore comments in config file and normalize whitespaces
	sed '/^ *#/d; s/#.*//; s/\s\+/ /g' < "$1" \
		| while read -r line; do
			mimetype_pattern="$(echo "$line" | cut -d' ' -f1)"
			case "$2" in
				$mimetype_pattern) 
					do_mimetype_action "$line" "$2" "$3"
					exit 0
					;;
			esac
		done
}






prepare() {
	lbrynet_start_if_needed

	get_local_lbrynet_config


	lbrynet_info="$(lbrynet_get "$url")"
	#echo "$lbrynet_info"
	case $lbrynet_info in
		\{* ) 
			# Assume valid JSON if starts with {
			;;
		* ) 
			print_error "Error: $lbrynet_info"
			exit 1
			;;
	esac


	error="$(result_value "$lbrynet_info" "error")"
	if [ "$error" != "null" ]; then
		print_error "Error: $error"
		exit 1
	fi
}


lbt_print_usage() {
	echo \
"Available commands:
	get 	Get content from an LBRY URL
	ls 	List stored LBRY content
	open 	Open LBRY content in the user's preferred application"
}


open() {
	options=mhfsq
	longopts=get-mime,help,save-file,force-stream,quiet
	parsed=$(getopt --options=$options --longoptions=$longopts --name "$0" -- "$@")
	eval set -- "$parsed"
#	echo "$@"

	while true; do
		case "$1" in
			-h|--help)
				help=y
				shift
				;;
			-m|--get-mime)
				get_mimetype=y
				shift
				;;
			-f|--save-file)
				save=y
				shift
				;;
			-s|--force-stream)
				force_stream=y
				shift
				;;
			-q|--quiet)
				quiet=y
				shift
				;;
			--)
				shift
				break
				;;
			*)
				echo "Programming error"
				echo "$1"
				exit 1
				;;
		esac
	done



	if [ -n "$help" ]; then
		lbt_help_open
		exit 0
	fi



	if [ -z "$1" ]; then
		echo "Usage: lbt open URL [option...]"
		echo "Try 'lbt open --help' to get more information"
		exit 1
	fi

	url="$(normalize_lbry_url "$1")"
	if [ "$url" != "$1" ]; then
		print_info "Resolving $url..."
	fi


	prepare

	mimetype=$(result_value "$lbrynet_info" "mime_type")

	if [ -n "$get_mimetype" ]; then
		echo "MIME type is $mimetype"
		exit 0
	fi

	handle_lbry_url "$config_dir/mimetypes" "$mimetype" "$url"
}




output_to_file() {
	if [ "$lbrynet_local" = y ] && is_download_complete "$2"; then
		download_path=$(result_value "$2" "download_path")
		if [ -n "$force_save" ]; then
			if [ -z "$quiet" ]; then
				printf "Copying from %s... " "$download_path"
			fi
			cp "$download_path" "$1"
			if [ -z "$quiet" ]; then
				echo "Done."
			fi
		else
			ln -s "$download_path" "$1"
			if [ -z "$quiet" ]; then
				echo "Created symlink from $1 to $download_path"
			fi
		fi
		exit 0
	fi
	if [ -n "$quiet" ]; then
		curl_initial_args="--silent"
	else
		curl_initial_args="--progress-meter"
	fi
	curl "$curl_initial_args" "$(result_value "$2" "streaming_url")" -o "$1"
	exit 0
}


get() {
	options=rhfsto:Fq
	longopts=resolve,help,file,stream,terminal,output:,force-save,quiet
	parsed=$(getopt --options=$options --longoptions=$longopts --name "$0" -- "$@")
	eval set -- "$parsed"
#	echo "$@"
	
	while true; do
		case "$1" in
			-h|--help)
				help=y
				shift
				;;
			-r|--resolve)
				resolve=y
				shift
				;;
			-f|--file)
				save=y
				shift
				;;
			-s|--stream)
				force_stream=y
				shift
				;;
			-t|--terminal)
				allow_terminal=y
				shift
				;;
			-o|--output)
				output_file="$2"
				shift 2
				;;
			-F|--force-save)
				force_save=y
				shift
				;;
			-q|--quiet)
				quiet=y
				shift
				;;
			--)
				shift
				break
				;;
			*)
				echo "Programming error: unknown parameter $1"
				exit 1
				;;
		esac
	done

	if [ -n "$help" ]; then
		lbt_help_get
	fi

	if [ -n "$quiet" ]; then
		allow_terminal=y
	fi

	if [ -z "$1" ]; then
		echo "Usage: lbt get URL -f|-s [option...]"
		echo "Try 'lbt get --help' to get more information"
		exit 1
	fi


	check_incompatible "$output_file" "$resolve" "--output" "--resolve"

	check_incompatible "$save" "$force_stream" "--file" "--stream"
	if [ -n "$save" ]; then
		action="save"
		if [ -z "$resolve" ]; then
			print_error "Error: --file option must be used with --resolve"
			exit 1
		fi
	elif [ -n "$force_stream" ]; then
		action="stream"
		if [ -z "$resolve" ]; then
			print_error "Error: --stream option must be used with --resolve"
			exit 1
		fi
	else
		if [ -n "$resolve" ]; then
			print_error "Error: either --file or --stream option must be used with --resolve"
			exit 1
		fi
	fi

	if [ -z "$resolve" ] && [ -z "$output_file" ] && [ -z "$allow_terminal" ] && [ -t 1 ]; then
		print_info "Are you sure you want to print this data into a terminal?"
		printf_info "\n(use the --terminal option to skip this)\033[F"
		printf_info "Type 'y' to proceed, or 'n' to exit: "
	
		first_print=y
		while read -r result; do
			if [ -n "$first_print" ]; then
				printf_info '\n'
				unset first_print
			fi

			if [ "$result" = y ]; then
				break
			elif [ "$result" = n ]; then
				exit 0
			fi
			printf_info "Type 'y' to proceed, or 'n' to exit: "
		done
	fi


	url="$(normalize_lbry_url "$1")"
	if [ "$url" != "$1" ]; then
		print_info "Resolving $url..."
	fi


	prepare



	if [ -n "$output_file" ]; then
		output_to_file "$output_file" "$lbrynet_info"
	elif [ -n "$resolve" ]; then
		lbry_get_url "$action" "$url"
	else
		if [ -z "$action" ]; then
			if is_download_complete "$lbrynet_info"; then
				cat "$(result_value "$lbrynet_info" "download_path")"
			else
				curl --silent "$(result_value "$lbrynet_info" "streaming_url")"
			fi
		elif [ "$action" = "save" ]; then
			if ! is_download_complete "$lbrynet_info"; then
				cat "$(download "$url")"
			else
				cat "$(result_value "$lbrynet_info" "download_path")"
			fi
		elif [ "$action" = "stream" ]; then
			curl --silent "$(result_value "$lbrynet_info" "streaming_url")"
		fi
	fi
}


lbrynet_list_files() {
	page=1
	total_pages=1
	

	# Download path must always be requested, so that we can later filter out
	# --files or --not-files claims
	columns="p: .download_path"
	if [ -z "$ls_no_name" ]; then
		columns="n: .claim_name, $columns"
	fi
	if [ -n "$ls_channel" ]; then
		columns="c: .channel_name, $columns"
	fi
	if [ -n "$ls_mime_type" ]; then
		columns="$columns, m: .mime_type"
	fi
	if [ -n "$ls_sd_hash" ]; then
		columns="$columns, h: .sd_hash"
	fi
	if [ -n "$ls_color" ] || [ -n "$ls_full" ] || [ -n "$ls_empty" ]; then
		columns="b: .blobs_completed, t: .blobs_in_stream, $columns"
	fi

	while [ $page -le $total_pages ]; do
		list_info="$(curl --silent -d"{\"method\": \"file_list\", \"params\": {\"page\": $page, \"page_size\": 1000000}}" "$api_server")"

		echo "$list_info" | jq ".result.items|.[]|{$columns}" | sed 's/,$//' | while read -r line; do
			case "$line" in
				\{ )
					continue
					;;
				\} )
					printf '\n'
					continue
					;;
			esac
			case "$line" in
				\"m\"* )
					printf '%s' "$line"
					;;
				\"b\"* )
					case "$line" in
						*": 0" )
							is_empty=y
							;;
						* )
							if [ -n "$ls_empty" ]; then
								printf '""DELETE THIS""'
							fi
							unset is_empty
							;;
					esac

					blobs_completed="$line"
					continue
					;;
				\"t\"* )
					if [ -n "$ls_files" ]; then
						is_full=y
					elif [ "$ls_color" = y ] || [ -n "$ls_full" ]; then
						blobs_completed="$(echo "$blobs_completed" | cut -d' ' -f2)"
						blobs_total="$(echo "$line" | cut -d' ' -f2)"
						if [ "$blobs_completed" -eq "$blobs_total" ]; then
							is_full=y
						else
							unset is_full
							if [ -n "$ls_full" ]; then
								printf '""DELETE THIS""'
							fi
						fi
					fi
					if [ -n "$ls_blobs" ]; then
						if [ "$ls_color" = y ]; then
							if [ -n "$is_full" ]; then
								printf '\033[38;5;2m'
							elif [ -n "$is_empty" ]; then
								printf '\033[38;5;1m'
							else
								printf '\033[38;5;3m'
							fi
						fi

						printf '%s/%s' "$blobs_completed" "$line"
						if [ "$ls_color" = y ]; then
							printf '\033[m'
						fi
						unset blobs_completed
					else
						unset blobs_completed
						continue
					fi
					;;
				"\"c\": null" )
					;;
				\"c\"* )
					if [ "$ls_color" = y ]; then
						printf '\033[38;5;6m%s\033[m' "$line"
					else
						printf '%s' "$line"
					fi
					;;
				\"n\"* )
					if [ "$ls_color" = y ]; then
						if [ -n "$is_full" ]; then
							printf '\033[38;5;2m'
						elif [ -n "$is_empty" ]; then
							printf '\033[38;5;1m'
						else
							printf '\033[38;5;3m'
						fi
						printf '\033[1m%s\033[m' "$line"
					else
						printf '%s' "$line"
					fi
					;;
				"\"p\": null")
					if [ -n "$ls_files" ]; then
						printf '""DELETE THIS""'
					fi
					;;
				\"p\"* )
					if [ -n "$ls_not_files" ]; then
						printf '""DELETE THIS""'
					elif [ -n "$ls_relative_path" ]; then
						filename="$(echo "$line" | cut -d' ' -f2)"
						filename="$(trim_quotes "$filename")"
						printf '%s' "$(realpath --relative-base="$PWD" "$filename")"
					elif [ -n "$ls_path" ]; then
						printf '%s' "$line"
					fi
					;;
				\"h\"* )
					printf '%s' "$line"
					;;
			esac
			printf ',\t'
		done | sed '/""DELETE THIS""/d; s/"\w": //g; s/"//g; s/,\t/"/g; s/"$//' | column -t -s'"'

		total_pages="$(result_value "$list_info" "total_pages")"
		page=$((page+1))
	done
}

lbt_ls() {
	options=hnNPcfFNbmder
	longopts=help,no-path,absolute-path,channel,files,not-files,no-name,blobs,mime-type,full,empty,color::,relative-path
	parsed=$(getopt --options=$options --longoptions=$longopts --name "$0" -- "$@")
	eval set -- "$parsed"
#	echo "$@"

	while true; do
		case "$1" in
			--color )
				case "$2" in
					"" )
						ls_color=y
						shift
						;;
					always )
						ls_color=y
						shift 2
						;;
					auto )
						shift 2
						;;
					never )
						ls_color=n
						shift 2
						;;
				esac
				;;
			-d|--full )
				ls_full=y
				shift
				;;
			-e|--empty )
				ls_empty=y
				shift
				;;
			-m|--mime-type )
				ls_mime_type=y
				shift
				;;
			-N|--no-name )
				ls_no_name=y
				shift
				;;
			-r|--relative-path)
				ls_relative_path=y
				shift
				;;
			-b|--blobs )
				ls_blobs=y
				shift
				;;
			#-H|--sd-hash )
			#	ls_sd_hash=y
			#	shift
			#	;;
			-f|--files )
				ls_files=y
				shift
				;;
			-F|--not-files )
				ls_not_files=y
				shift
				;;
			-h|--help )
				help=y
				shift
				;;
			-n|--no-path )
				ls_no_path=y
				shift
				;;
			-P|--absolute-path )
				ls_path=y
				shift
				;;
			-c|--channel )
				ls_channel=y
				shift
				;;
			-- )
				shift
				break
				;;
			* )
				echo "Programming error"
				echo "$1"
				exit 1
				;;
		esac
	done

	check_incompatible "$ls_no_path" "$ls_path" "--no-path" "--absolute-path"
	check_incompatible "$ls_relative_path" "$ls_path" "--relative-path" "--absolute-path"
	check_incompatible "$ls_relative_path" "$ls_no_path" "--relative-path" "--no-path"
	if [ -z "$ls_no_path" ] && [ -z "$ls_path" ] && [ -z "$ls_relative_path" ]; then
		if [ -t 1 ]; then
			ls_relative_path=y
		else
			ls_path=y
		fi
	fi

	check_incompatible "$ls_full" "$ls_empty" "--full" "--empty"

	if [ -z "$ls_color" ]; then
		if [ -t 1 ]; then
			ls_color=y
		else
			ls_color=n
		fi
	fi

	check_incompatible "$ls_no_name" "$ls_no_path" "--no-name" "--no-path"
	if [ -n "$ls_no_name" ]; then
		if [ -z "$ls_files" ]; then
			print_error "Error: --no-name option requires --files"
			exit 1
		fi
	fi

	check_incompatible "$ls_files" "$ls_not_files" "--files" "--not-files"


	if [ -n "$help" ]; then
		lbt_help_ls
		exit 0
	fi


	lbrynet_start_if_needed
	get_local_lbrynet_config


	lbrynet_list_files
}

lbt_help_generic() {
	echo "Usage: lbt COMMAND..."
	lbt_print_usage			
	echo "Try lbt -h [COMMAND] for more info"
}

while true; do
	case "$1" in
		"open")
			lbt_command="open"
			shift
			break
			;;
		"get")
			lbt_command="get"
			shift
			break
			;;
		"ls")
			lbt_command="ls"
			shift
			break
			;;
		"-h"|"--help")
			lbt_help=y
			shift
			;;
		"")
			lbt_help_generic
			if [ -n "$lbt_help" ]; then
				exit 0
			else
				exit 1
			fi
			;;
		*)
			echo "Unknown command: $1"
			lbt_print_usage
			exit 1
			;;
	esac
done

case "$lbt_command" in
	open )
		if [ -n "$lbt_help" ]; then
			lbt_help_open
			exit 9
		fi
		open "$@"
		;;
	get )
		if [ -n "$lbt_help" ]; then
			lbt_help_get
			exit 9
		fi
		get "$@"
		;;
	ls )
		if [ -n "$lbt_help" ]; then
			lbt_help_ls
			exit 9
		fi
		lbt_ls "$@"
		;;
	* )
		echo "Programming error: unknown command??"
		exit 1
		;;
esac

